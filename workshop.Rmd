---
title: "Workshop for Simmer in R training"
description: Based on previous workshops in Simul8 and JaamSim using a primary care example
author: Stacey Croft, Anastasiia Zharinova and Tom Jemmett
date: 28^th^ July 2021
output:
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
    df_print: "kable"
    css: strategy_unit.css
---

# Introduction

This workshop builds a discrete event simulation model using a primary care example. The model worksheet and supporting material (slides, videos etc) can be found [here](https://future.nhs.uk/GPsal/view?objectId=29002352).

It outlines the scenarios, giving a flow chart of the flow of patients through the activities. It then gives prompts on how to construct the model, as well as asking questions after each section.

## Setting up

Modifying the colours used 

```{r setup}
# simplified version of StrategyUnitTheme::su_theme_pal()
#   see: https://github.com/The-Strategy-Unit/StrategyUnitTheme
su_theme_pal <- function(palette = "main", ...) {
  pal <- c(orange = "#f9bf07",
           red    = "#ec6555",
           blue   = "#5881c1")
  grDevices::colorRampPalette(pal, ...)
}
```

If you haven't already got these packages installed you will need the following to complete this workshop:

```{r install packages, eval = FALSE}
install.packages(c("tidyverse", "simmer", "simmer.plot", "gridExtra", "TruncatedNormal","xlsx","ggplot2"))
```

# Part 1 - Initial Model

## Libraries

```{r libraries}
suppressPackageStartupMessages({
  library(tidyverse)
  library(simmer)
  library(simmer.plot)
  library(TruncatedNormal)
  library(writexl)
  library(gridExtra)
})
```
## Environment 

Create a simulation environment for "env_part1".

```{r part 1: create environment}
env_part1 <- simmer("part1")
env_part1
```

## Continuous distribution functions

There are 4 time related distributions to create: 
- the patients interarrival rate, 
- the time taken for asking the screening questions
- the time for the receptionists to make the decision on what appointment to book 
- and the booking of the appointment (if needed).

```{r part 1: example distribution}
# generic exponential distribution 
rexp(n = 1, rate = 1 )
# generic truncated normal distributions looks like:
rtnorm(n = 1, mu = 1, sd = 0.25, lb = 0, ub = Inf)
```

You can use helper functions, one option:

```{r part 1: create continuous distribution functions (first option)}
dist_helper <- function(rfn, ...) {
  function() rfn(1, ...)
}
dist_patient_interarrival <- dist_helper(rexp, 50 / 60)
dist_screening            <- dist_helper(rtnorm, 4, 1,    0, Inf)
dist_decision             <- dist_helper(rtnorm, 1, 0.25, 0, Inf)
dist_booking              <- dist_helper(rtnorm, 1, 0.25, 0, Inf)
```

Alternatively:

```{r part 1: create continuous distribution functions (second option)}
dist_patient_interarrival <- function() rexp(1, 50 / 60)
dist_screening            <- function() rtnorm(n = 1, mu = 4, sd = 1, lb = 0, ub = Inf)
dist_decision             <- function() rtnorm(n = 1, mu = 1, sd = 0.25, lb = 0, ub = Inf)
dist_booking              <- function() rtnorm(n = 1, mu = 1, sd = 0.25, lb = 0, ub = Inf)
```

## Discrete distributions

Create functions to sample from discrete distributions for routing the patient entities at the branches in the model. 
-	Which mode of contact the patients will use, electronic vs phone 
-	For whether no appointment, phone appointment or face to face appointment is given

```{r part 1: create discrete distribution functions}
dist_contact_mode         <- function() sample(1:2, 1, FALSE, c(0.15, 0.85))
dist_booking_type         <- function() sample(1:3, 1, FALSE, c(0.3, 0.6, 0.1))
```

## Branch trajectories

Think about the flow diagram of the process to create the trajectories for the model, let's break it down into manageable sections.

### ECR branch

Create a trajectory for this branch called `branch_ecr`. Within the trajectory use set_attribute `via_ecr` to label the patient with a value of 1, so we will know what route they have come to analyse later. Then seize a receptionist ready for the next stage of the process.

```{r part 1: branch ecr}
branch_ecr <- trajectory("branch ecr") %>%
  set_attribute("via_ecr", 1) %>%
  seize("receptionist")
```

### Phone branch

Create a renege trajectory, the patients renege (hang up) after 5 minutes so log this and set the attribute `"reneged"` to 1.

Create a trajectory for this branch called `branch_phone`. Within the trajectory use set_attribute `via_ecr` to label the patient with a value of 0 (as opposed to 1 which are ECR route patients). Set the renege trajectory. Then seize a receptionist ready for the next stage. Once the patient has a receptionist abort the renege and add timeout of distribution screening

```{r part 1: branch phone}
renege_hungup <- trajectory("hung up") %>%
  set_attribute("reneged", 1) %>%
  log_("lost my patience. Hanging up...")

branch_phone <- trajectory("branch phone") %>%
  set_attribute("via_ecr", 0) %>%
  renege_in(t = 5, out = renege_hungup) %>%
  seize("receptionist") %>%
  renege_abort() %>% # now have a receptionist the patient won't renege
  timeout(dist_screening)
```

We'll look at an alternative way, Option B, to set this branch up later on.

### Appointment outcome branches

The branches of the trajectory after the receptionist decides if a patient needs a face to face appointment, phone appointment or does not need any appointment. Using set_attribute to record the outcome and the time taken to make the booking where appropriate.

```{r part 1: branch booking none}
branch_booking_none <- trajectory("no appointment needed") %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 0)
```

```{r part 1: branch booking phone}
branch_booking_phone <- trajectory("booking a phone") %>%
  timeout(dist_booking) %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 1)
```

```{r part 1: branch booking face to face}
branch_booking_f2f <- trajectory("booking a f2f") %>%
  timeout(dist_booking) %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 2)
```

## Overall Patient Trajectory {#p1_trj}

Create the overall patient flow trajectory by including the branch for the contact modes, then the time for whether to book an appointment, followed by the branch for the outcomes of that decision (none/phone/F2F).

```{r part 1: patient flow trajectory}
patient_flow <- trajectory("patient flow") %>%
  branch(dist_contact_mode, TRUE,
         branch_ecr,
         branch_phone) %>%
  timeout(dist_decision) %>%
  branch(dist_booking_type, TRUE,
         branch_booking_none,
         branch_booking_phone,
         branch_booking_f2f)

patient_flow 

plot(patient_flow, fill = su_theme_pal("main"))

# you can change the verbose argument to TRUE to get more information
plot(patient_flow, fill = su_theme_pal("main"), verbose = TRUE)
```

## Populate environment

Add the 2 receptionists as a resource. 
Add a generator to control the arrival of patient contacts to your trajectory using to(stop_time, dist), where stop time is 600 (10 hours =10 * 60 minutes=600 minutes) and set mon=2 to include additional attribute monitoring. Use to() with caution as the stop time is that of the generator and not the simulation. 

```{r part 1: add resources and entity generator}
env_part1 <- simmer("part 1") %>%
  add_resource("receptionist", 2) %>%
  add_generator("patient", patient_flow, to(8 * 60, dist_patient_interarrival), mon = 2)
```

## Run the model

The simulation will run until all arrivals are finished, as we haven't specified a time in the run command. We are assuming that staff stay overtime to finish. 
Setting a seed value makes it so we always get the same starting point for random numbers, making our results repeatable, the choice of seed is not important here.

```{r part 1: run the model, include=FALSE}
set.seed(1)
env_part1 %>%
  run()
```

## Glimpse results 

This helps us check how the model has run:

```{r part 1: results}
env_part1 %>%
  get_mon_arrivals() %>%
  arrange(start_time) %>%
  head(10)
env_part1 %>%
  get_mon_arrivals() %>%
  arrange(start_time) %>%
  tail(10)
```

## Part 1 Questions

If you are new to R and struggling with data manipulation, you can export the results as xlsx or csv. Or email us and we can help you!

```{r optional data export, eval = FALSE}
write_xlsx(get_mon_arrivals(env_part1), "arrivals_part1.xlsx")
write_xlsx(get_mon_resources(env_part1), "resources_part1.xlsx")
write_xlsx(get_mon_attributes(env_part1), "attributes_part1.xlsx")
```

### Q1.	How many patients fail to speak to the receptionist (renege)?

#### Count reneged: 

This can be done via get_mon_attributes() and filtering appropriate attribute

```{r part 1: q1}
env_part1 %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  summarise(countreneged = n())
```

countreneged=151 

### Q2.	How many people get a F2F booking? 

#### Count F2F bookings: 

This can be done via get_mon_attributes() and selecting appropriate attribute and value

```{r part 1: q2}
env_part1 %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  summarise(countF2F = n())
```

countF2F=28

### Q3.	What can you say about the wait for call to be answered?

#### Call waits:

Firstly, we will use the get_mon_attributes() function to get attributes such as reneged and ECR of finished patients. It is helpful to use: pivot_wider(names_from = "key", values_from = "value", values_fill = 0) as part of this.

```{r part 1: q3 a}
part1_attributes <- env_part1 %>%
  get_mon_attributes() %>%
  dplyr::select(-time) %>%
  pivot_wider(names_from = "key", values_from = "value", values_fill = 0)
```

We will then join it with arrivals obtained from get_mon_arrivals(). Filter those who came through phone branch and calculate call wait time as a difference between total time in the system (end time - start time) and activity time. We will also set waiting time as 5 min for those who reneged. The current model has no unfinished and so we do not consider them here. 
Due to rounding issues, you might get very low negative values for waiting times, e.g. 9*10-16. To solve it, we will substitute negative values with 0 via pmax(end_time - start_time - activity_time, 0).

```{r part 1: q3 b}
part1_callwait_results <- env_part1 %>%
  get_mon_arrivals(ongoing = TRUE) %>% # not needed as there aren't any due to the generator and run()
  inner_join(part1_attributes, by = c("name", "replication")) %>%
  filter(via_ecr == 0) %>%
  mutate(wait_time_call = case_when(
    # the caller reneged
    reneged == 1 ~ 5,
    # everything else, (assume has been answered)
    TRUE      ~ pmax(end_time - start_time - activity_time, 0)
  ))
```

Once done, we can calculate desired statistics such as minimum, maximum, mean and quantiles.

```{r part 1: q3 c}
part1_callwait_summary <- part1_callwait_results %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(!finished),
            countfinished = sum(finished))

part1_callwait_summary
```


### Additional analysis

Glimpse the end tail and also check whether ECR backlog is cleared at the end of the days. Overall backlog - let's look at 1 replication

```{r part 1 extra data exploring}
attributes <- env_part1 %>%
  get_mon_attributes() %>%
  filter(replication == 1)

test <- env_part1 %>%
  get_mon_arrivals() %>%
  filter(finished == FALSE, replication == 1) %>%
  inner_join(attributes, by = "name") %>%
  arrange(start_time)

test

env_part1 %>%
  get_mon_attributes() %>%
  filter(replication == 1, key == "via_ecr", value == 1) %>%
  count()
```

You can see that everyone finished and we had total of 66 ECR.

## Option B - Alternative way to calculate waiting time

An alternative way to do this, uses the way described above but with the addition of setting an attribute for the time of events. However, this way will make code more complex when we get to part 3 - multiple replications but might be useful to see for application in other models with more comlex trajectories.

### New environment
```{r part 1B env}
env_part1B <- simmer("part 1B") 
env_part1B
```

### Branch trajectories

Phone branch: As Option A with the addition of setting an attribute for the time of events e.g. the time a patients call is answered using 'now(env_part1)'. 

```{r part 1B phone branch}
renege_hungupB<-trajectory("hung up")%>%
  set_attribute("reneged", 1)%>% 
  set_attribute("reneged_at", function() now(env_part1B)) %>%#Opt.B addition
  log_("lost my patience. Hanging up...")

branch_phoneB <- trajectory("branch phone") %>%
  set_attribute("via_ecr", 0) %>%
  set_attribute("arrival", function() now(env_part1B)) %>%#Opt.B addition
  renege_in(t=5, out=renege_hungup)%>%
  seize("receptionist") %>%
  set_attribute("call_taken", function() now(env_part1B)) %>%#Opt.B addition
  renege_abort() %>%# now have a receptionist the patient won't renege
  timeout(dist_screening)
```

Outcome branches: As option A but with additional set attributes

```{r part 1B outcome branches}
#No appointment needed: 
branch_booking_noneB <- trajectory("no appointment needed") %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 0)%>%
  set_attribute("call_end", function() now(env_part1B))#Opt.B addition

#Phone appointment needed:
branch_booking_phoneB <- trajectory("booking a f2f") %>%
  timeout(dist_booking)%>%
  release("receptionist") %>%
  set_attribute("booked_appt", 1)%>%
  set_attribute("call_end", function() now(env_part1B))#Opt.B addition

#Face to Face appointment needed:
branch_booking_f2fB <- trajectory("booking a f2f") %>%
  timeout(dist_booking)%>%
  release("receptionist")%>%
  set_attribute("booked_appt", 2)%>%
  set_attribute("call_end", function() now(env_part1B))#Opt.B addition
```

### Overall trajectory

Create the overall patient flow trajectory as OptionA but using the Option B branches

```{r part1B overall traj}
patient_flowB <- trajectory("patient flowB") %>%
  branch(dist_contact_mode, TRUE,
         branch_ecr,
         branch_phoneB) %>%
  timeout(dist_decision) %>%
  branch(dist_booking_type, TRUE,
         branch_booking_noneB,
         branch_booking_phoneB,
         branch_booking_f2fB)
```

Look at option B's trajectory, note the additional set attributes to the plot produced by option A

```{r part 1B option B traj plot}
plot(patient_flowB, fill=su_theme_pal("main"))
```

### Populate and run option B environment

As before but using the option B trajectory

```{r part 1B populate}
env_part1B <- simmer("part 1B") %>%
  add_resource("receptionist", 2) %>%
  add_generator("patient", patient_flowB, to(10 * 60, dist_patient_interarrival),mon=2)
```

Run Part 1B model

```{r part 1B run}
set.seed(1)
env_part1B %>% run()
```

### Part1B Questions

#### Count reneged:

Q1. How many patients fail to speak to the receptionist (renege)?

```{r part 1B Q1}
env_part1B%>%  
  get_mon_attributes() %>% 
  filter(key=="reneged")%>%
  summarise(countreneged=n())
```

n=151, same as before

#### Count F2F bookings:

Q2.	How many people get a F2F booking?

```{r part 1B Q2}
env_part1B%>%  
  get_mon_attributes() %>% 
  filter(key=="booked_appt"&value==2)%>%
  summarise(countF2F=n())
```

n=28, same as before

#### Call waits: 

Q3.	What can you say about the wait for call to be answered?

The attribute data can be used to calculate call waiting time from the recorded times in the attributes, remembering to include 5 min for those who reneged. We don't have any unfinished calls in our model but we could use the duration of the run and the time they entered the queue to get this. This approach will cause extra complexity in part 3 of the workshop, but it might work better in other models when you have different resources and servers.

```{r part 1B Q3a}
part1B_callwait_results<-env_part1B%>%
  get_mon_attributes() %>%
  pivot_wider(-c(time, replication), names_from = key, values_from = value) %>%
  filter(via_ecr==0 & arrival>=0) %>%
  mutate(wait_time_call=ifelse(is.na(reneged),
                                      call_taken - arrival,#has been answered
                               5))# has reneged
```

Then calculate desired summary statistics as before. 

```{r part 1B Q3b}
part1B_callwait_summary<-part1B_callwait_results%>%
  summarise(median_wait=median(wait_time_call),
            mean_wait=mean(wait_time_call),
            var_wait=var(wait_time_call),
            min_wait=min(wait_time_call), 
            max_wait=max(wait_time_call),
            Qtile25th_wait=quantile(wait_time_call, probs=0.25),
            Qtile75th_wait=quantile(wait_time_call, probs=0.75),
            countunfinished=sum(case_when(is.na(call_end) & is.na(reneged)~ 1, TRUE ~ 0)),
            countfinished=sum(case_when(!is.na(call_end) | !is.na(reneged)~1, TRUE ~ 0))) 

part1B_callwait_summary
```

# Part 2 - Updated Model Features

The worksheet outlines some additional features to include in the model:
- Time-dependent interarrival times
- Time-dependent resources (staffing)
- Prioritisation of phone calls over electronic requests

## Environment

Create a new environment

```{r part 2: new environment}
env_part2 <- simmer("part2")
env_part2
```

## Time-dependent interarrival times

It's helpful to use these helper functions to switch between minutes, hours and day.

```{r part 2: time helper functions}
t_minute <- function(t) t
t_hour   <- function(t) t_minute(t) * 60
t_day    <- function(t) t_hour(t) * 24
```

To include time dependent interarrivals we create a different distribution, one for each time period (3 in total).

```{r part 2: time-dependent interarrivals }
dist_patient_interarrival1 <- function() rexp(1, 120 / t_hour(2))
dist_patient_interarrival2 <- function() rexp(1, 240 / t_hour(6))
dist_patient_interarrival3 <- function() rexp(1,  40 / t_hour(2))
```

## Prioritisation of phone branch

We are also going prioritise the patients contacting the surgery via the phone.

In the ECR branch, no changes are needed. The default priority for all arrivals is set up to 0.

In the phone branch, we want to set a higher priority using set_prioritization(), that receptionists prioritise answering calls over reviewing electronic requests but without interrupting current tasks (`prioirity = 1`, `preemptive = 1`, `restart = FALSE`). If you didn't use now(env_part1) to set attributes you can use join(branch_phone) instead to link after the prioritisation back to your original phone branch.

```{r part 2: phone branch with prioritisation}
branch_phone2 <- trajectory("branch phone prioritised") %>%
  set_prioritization(c(1, 1, FALSE)) %>%
  join(branch_phone)

plot(branch_phone2, fill = su_theme_pal("main"))
```

from the help page for `add_generator()`:
- `priority`: the priority of each arrival (a higher integer equals higher priority; defaults to the minimum priority,
which is 0.
- `preemptible`: if a seize occurs in a preemptive resource, this parameter establishes the minimum incoming priority that can preempt these arrivals (an arrival with a priority greater than `preemptible` gains the resource). In any case, `preemptible` must be equal or greater than priority, and thus only higher priority arrivals can trigger preemption.
- `restart`: whether the activity must be restarted after being preempted.

## Patient Trajectory

Create the overall patient trajectory again, the same as [Part 1](#p1_trj) but with the new prioritised phone branch

```{r part 2: patient trajectory}
patient_flow2 <- trajectory("patient flow2") %>%
  branch(dist_contact_mode, TRUE,
         branch_ecr,
         branch_phone2) %>% #<-- changed the phone branch
  timeout(dist_decision) %>%
  branch(dist_booking_type, TRUE,
         branch_booking_none,
         branch_booking_phone,
         branch_booking_f2f)

plot(patient_flow2, fill = su_theme_pal())
```

## Schedule for staffing

Use the schedule(timetable, values, period) function and set it to repeat the schedule every 24 hour period. Work out from the numbers on each shift what times capacity changes and how many are working at that point: e.g. 0-8am = 0, 8-9am = 1, 9-9.30 am = 2 etc....

```{r part 2: staff schedule}
sch_receptionists <- schedule(
  timetable = t_hour(c(0.0, 8.0, 9.0, 9.5, 12.0, 15.5, 18.0)),
  values    =        c(0,   1,   2,   4,    3,    1,    0),
  period    = t_hour(24)
)
```

## Populate and run the model

Add the receptionists as a resource using the schedule you created for the capacity. Either add three different generators to the model environment setting the times they operate with from_to or use functional programming to control this. You can look back at the training slides and examples to help you.

```{r part 2: add resources and entity generator}
env_part2 %>%
  add_resource("receptionist", capacity = sch_receptionists) %>%
  add_generator("patient[8am-10am]", patient_flow2,
                from_to(t_hour(8), t_hour(10), dist_patient_interarrival1, every = t_day(1)),
                mon = 2) %>%
  add_generator("patient[10am-4pm]", patient_flow2,
                from_to(t_hour(10), t_hour(16), dist_patient_interarrival2, every = t_day(1)),
                mon = 2) %>%
  add_generator("patient[4pm-6pm]", patient_flow2,
                from_to(t_hour(16), t_hour(18), dist_patient_interarrival3, every = t_day(1)),
                mon = 2)
```

Set the random seed to 1 to give us the same results each time. Run the model for 5 days (5*24*60) or use one of the time helper functions.

```{r part 2: run model, include=FALSE}
set.seed(1)
env_part2 %>%
  run(t_day(5))
```

## Part 2 Questions

### Q1. What is the average wait for calls to be answered, number abandoning their calls (hanging up) and the number booked for a face to face appointment in this simulated week?

Repeat the analysis of call waits, reneging and F2F appointments as for part 1 using the environment for part 2. 

#### Count reneged:

```{r part 2: q1}
env_part2 %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  summarise(countreneged = n())
```

n = 582

#### Count F2F bookings:

```{r part 2: q2}
env_part2 %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  summarise(countF2F = n())
```

n = 160

#### Call waits:

```{r part 2: q3}
part2_attributes <- env_part2 %>%
  get_mon_attributes() %>%
  dplyr::select(-time) %>%
  pivot_wider(names_from = "key", values_from = "value", values_fill = 0)

part2_callwait_results <- env_part2 %>%
  get_mon_arrivals(ongoing = TRUE) %>%
  full_join(part2_attributes, by = c("name", "replication")) %>% # or can use inner_join
  filter(via_ecr == 0) %>%
  mutate(wait_time_call = case_when(
    reneged == 1 ~ 5,
    TRUE      ~ pmax(end_time - start_time - activity_time, 0)
  ))

part2_callwait_summary <- part2_callwait_results %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(!finished),
            countfinished = sum(finished))

part2_callwait_summary
```

### Q2. What else would you do to improve this model?

Some ideas:
* prevent staff staying to finish all just the one they are on,
* multiple runs,
* staff breaks, availability, are they also doing other tasks?

### Q3. What other metrics would you want to measure / the practice find useful?

Below are some ideas on additional analysis you might want to do.

#### Plot waiting time over time

```{r part 2: show waiting times plot, warning=FALSE}
plot(get_mon_arrivals(env_part2), metric = "waiting_time")
```

#### Boxplot to show variation in metrics e.g. call_wait

```{r part 2: boxplot part2 callwait, warning=FALSE}
g1 <- ggplot() +
  geom_boxplot(data = part2_callwait_results,
               aes(x = "rep=1", y = wait_time_call),
               outlier.shape = 19,
               width = 0.3,
               fill = "white",
               colour = "orange") +
  geom_point(data = part2_callwait_summary,
             aes(x = "rep=1", y = mean_wait),
             shape = 19,
             size = 2,
             colour = "red") +
  labs(x = "Part2",
       y = "call wait (mins)",
       title = "Boxplot of call wait from single replication") +
  theme(axis.text = element_text(size = 11))

g1
```

#### Unfinished at end of the simulation

Glimpse the end tail and also check whether ECR backlog is cleared at the end of the days. Overall backlog:

```{r part 2: unfinished part2}
attributes <- env_part2 %>%
  get_mon_attributes() %>%
  filter(replication == 1)

test <- env_part2 %>%
  get_mon_arrivals() %>%
  filter(finished == FALSE, replication == 1) %>%
  inner_join(attributes, by = "name") %>%
  arrange(start_time)

test %>%
  filter(key == "via_ecr", value != 1)

env_part2 %>%
  get_mon_attributes() %>%
  filter(replication == 1, key == "via_ecr", value == 1) %>%
  count()

test %>%
  head(10) %>%
  as_tibble()
```

All unfinished are ECR, because calls were prioritised ahead of them. 357 total ECR.

#### Staff utilisation by hour

Look at resources (reception staff in this example)

```{r part 2: analyse resources, warning=FALSE}
resources2 <- get_mon_resources(env_part2)
plot(resources2, metric = "usage", "receptionist", items = "server", steps = TRUE)
plot(resources2, metric = "utilization", "receptionist")

# show the top 10 results
head(resources2, n = 10)

# list of hours
HrList <- data.frame(
  resource = "receptionist",
  time = seq(from = 0, to = t_day(5), by = 60),
  server = NA,
  queue = NA,
  capacity = NA,
  queue_size = Inf,
  system = NA,
  limit = Inf,
  replication = 1
)

# which aren't in the data
AddSnaps <- filter(HrList, !(time %in% resources2$time))

resources2_hourly <- bind_rows(resources2, AddSnaps) %>%
  arrange(time) %>%
  mutate(server = ifelse(is.na(server), lag(server), server),
         queue = ifelse(is.na(queue), lag(queue), queue),
         capacity = ifelse(is.na(capacity), lag(capacity), capacity),
         system = ifelse(is.na(system), lag(system), system))

resourceutilisation_byhour <- resources2_hourly %>%
  arrange(time) %>%
  mutate(slot_hour = floor(time / 60)) %>%
  mutate(slot_day = ceiling(slot_hour / 24)) %>%
  mutate(slot = slot_hour - ((slot_day - 1) * 24)) %>%
  group_by(slot) %>%
  mutate(dt = time - lag(time),
         capacity = ifelse(capacity < server, server, capacity),
         in_use = dt * lag(server / capacity)) %>%
  summarise(utilised_percent = sum(in_use, na.rm = TRUE) / sum(dt, na.rm = TRUE) * 100)

resourceutilisation_byhour
```

## Option B - How to use to do Part 2

Alternative way using Option B, if we used now(env_part1) to set attributes then code needs to change environment for all parts of the trajectory in which it was used.c
The overall trajectory is then created again using the new versions.

### New environment

Firstly, create a new environment.

```{r part 2: option B, warning=FALSE}
env_part2B <- simmer("part 2B")
env_part2B
```

### Reference env in attributes

Change references to part env_part2B in all trajectories using now(env_part2B.

```{r part 2: option B 2, warning=FALSE}
renege_hungup2B <- trajectory("hung up") %>%
  set_attribute("reneged", 1) %>%
  set_attribute("reneged_at", function() now(env_part2B)) %>% # changed to env_part2B
  log_("lost my patience. Hanging up...")

branch_phone2B <- trajectory("branch phone") %>%
  set_prioritization(c(1, 1, FALSE)) %>% # set to increase priority from default of 0 to 1, no preempt and no restart
  set_attribute("via_ecr", 0) %>%
  set_attribute("arrival", function() now(env_part2B)) %>% # changed to env_part2B
  renege_in(t = 5, out = renege_hungup) %>%
  seize("receptionist") %>%
  set_attribute("call_taken", function() now(env_part2B)) %>% # changed to env_part2B
  renege_abort() %>%
  timeout(dist_screening)

branch_booking_none2B <- trajectory("no appointment needed") %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 0) %>%
  set_attribute("call_end", function() now(env_part2B)) # changed to env_part2B

branch_booking_phone2B <- trajectory("booking a f2f") %>%
  timeout(dist_booking) %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 1) %>%
  set_attribute("call_end", function() now(env_part2B)) # changed to env_part2B

branch_booking_f2f2B <- trajectory("booking a f2f") %>%
  timeout(dist_booking) %>%
  release("receptionist") %>%
  set_attribute("booked_appt", 2) %>%
  set_attribute("call_end", function() now(env_part2B)) # changed to env_part2B

patient_flow2B <- trajectory("patient flow2B") %>%
  branch(dist_contact_mode, TRUE,
         branch_ecr,
         branch_phone2B) %>%
  timeout(dist_decision) %>%
  branch(dist_booking_type, TRUE,
         branch_booking_none2B,
         branch_booking_phone2B,
         branch_booking_f2f2B)
```

### Populate and run Part 2B

Populate environment using the trajectory for patient flow 2B

```{r part 2: option B 3, warning=FALSE}
env_part2B %>%
  add_resource("receptionist", capacity = sch_receptionists) %>%
  add_generator("patient[8am-10am]", patient_flow2B,
                from_to(t_hour(8), t_hour(10), dist_patient_interarrival1, every = t_day(1)),
                mon = 2) %>%
  add_generator("patient[10am-4pm]", patient_flow2B,
                from_to(t_hour(10), t_hour(16), dist_patient_interarrival2, every = t_day(1)),
                mon = 2) %>%
  add_generator("patient[4pm-6pm]", patient_flow2B,
                from_to(t_hour(16), t_hour(18), dist_patient_interarrival3, every = t_day(1)),
                mon = 2)
```

Run the model for 5 days

```{r part 2: option B run, warning=FALSE, include=FALSE}
set.seed(1)
env_part2B %>%
  run(t_day(5))
```

### Part 2 Questions using Option B

Q1. What is the average wait for calls to be answered, number abandoning their calls (hanging up) and the number booked for a face to face appointment in this simulated week?

#### Count reneged: 

```{r part 2: option B Q1, warning=FALSE}
env_part2B %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  summarise(countreneged = n())
```

n=582

#### Count F2F bookings:

```{r part 2: option B Q2, warning=FALSE}
env_part2B %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  summarise(countF2F = n())
```

n=160

#### Call waits:

```{r part 2: option B Q3, warning=FALSE}
part2B_callwait_results <- env_part2B %>%
  get_mon_attributes() %>%
  pivot_wider(-c(time, replication), names_from = key, values_from = value) %>%
  filter(via_ecr == 0, arrival >= 0) %>%
  mutate(wait_time_call = case_when(
    !is.na(reneged) ~ 5,
    is.na(call_taken) ~ t_day(5) - arrival, # in queue/progress still, model run for 5 days
    TRUE ~ call_taken - arrival # has been answered
  ))

part2B_callwait_summary <- part2B_callwait_results %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(is.na(call_end) & is.na(reneged)),
            countfinished = sum(!is.na(call_end) | !is.na(reneged)))

part2B_callwait_summary
```

# Part 3 Multiple runs and Scenarios

Now we are going to run our model 50 times and analyse different scenarios.

## Baseline replications {#p3_baserep}

Use lapply to loop through and replicate the environment you created in Part 2 50 times. 

```{r part 3: replicate model runs, include=FALSE}
envs_baseline <- lapply(1:50, function(i) {
  set.seed(i)
  simmer("baseline") %>%
    add_resource("receptionist", capacity = sch_receptionists) %>%
    add_generator("patient[8am-10am]", patient_flow2,
                  from_to(t_hour(8), t_hour(10), dist_patient_interarrival1, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[10am-4pm]", patient_flow2,
                  from_to(t_hour(10), t_hour(16), dist_patient_interarrival2, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[4pm-6pm]", patient_flow2,
                  from_to(t_hour(16), t_hour(18), dist_patient_interarrival3, every = t_day(1)),
                  mon = 2) %>%
    run(t_day(5))
})
```

(Note mclapply function from the ‘parallel’ package could also be used to run each simulation in parallel, using the available cores in the computer’s processor. See here for an example: https://r-simmer.org/articles/simmer-04-bank-1.html)

## Baseline results

Update some of the code used to look at results in parts 1 and 2. This time group_by(replication) before we summarise. E.g count of the reneged, then ungroup(). This will give the result for each replication. It is these that are then summarised again to give the final results for i.e. the mean of the mean number reneged in each replication.

Count reneged

```{r part 3: count reneged, warning=FALSE}
envs_baseline %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  group_by(replication) %>%
  summarise(countreneged = n()) %>%
  ungroup() %>%
  summarise(countreneged_mean = mean(countreneged))
```

n=580

Count F2F

```{r part 3: count F2F, warning=FALSE}
envs_baseline %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  group_by(replication) %>%
  summarise(countF2F = n()) %>%
  ungroup() %>%
  summarise(countF2F_mean = mean(countF2F))
```

n=143

Before we look at call waits let's understand a little more about unfinished. Using the staff schedule means that the final staff member finishes at 6pm on the 5th day so at (4*24*60)+(18*60)= 6840, there are 4 in the system, 1 patient in progress and 3 waiting the staff member finishes that one at 6845 and then leaves with 3 remaining unfinished a similar thing occurs at the end of day 3.

```{r part 3: unfinished, warning=FALSE}
get_mon_resources(envs_baseline) %>%
  filter(replication == 1) %>%
  tail(n = 10) # show last 10 rows

get_mon_resources(envs_baseline) %>%
  filter(replication == 1, time < 6240) %>%
  tail(n = 10)
```

We also need to consider duplicates in our results.

```{r part 3: duplicates}
envs_baseline %>%
  get_mon_arrivals(ongoing = TRUE) %>% # 101972 rows
  filter(replication == 1, is.na(end_time))%>%
  head(n=10)
```

Now considering this let's calculate the call waits:

```{r part 3: call waits, warning=FALSE}
baseline_attributes <- envs_baseline %>%
  get_mon_attributes() %>% #202732 obs
  dplyr::select(-time) %>%
  pivot_wider(names_from = "key", values_from = "value", values_fill = 0)
#101468 obs

baseline_callwait_results <- envs_baseline %>%
  get_mon_arrivals(ongoing = TRUE) %>%
  distinct() %>% # goes down to 101618, removes duplicates of unfinished
  # still more in arrivals than attributes as attributes only has finished
  full_join(baseline_attributes, by = c("name", "replication")) %>%
  filter(via_ecr == 0) %>% # phone only also removes those yet to start e.g. start_time -1
  mutate(wait_time_call = case_when(
    # the caller reneged
    reneged == 1 ~ 5,
    # unfinished still in the system,
    !finished ~ t_day(5) - start_time,
    # everything else, (assume has been answered)
    TRUE      ~ pmax(end_time - start_time - activity_time, 0)
  ))

## calculate summary statistics
baseline_callwait_replication_summary <- baseline_callwait_results %>%
  group_by(replication) %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(!finished),
            countfinished = sum(finished)) %>%
  mutate(scenario = "baseline")

# show top 10 rows
head(baseline_callwait_replication_summary, n = 10)

baseline_callwait_summary <- baseline_callwait_replication_summary %>%
  summarise(median_wait = mean(median_wait),
            mean_wait = mean(mean_wait),
            var_wait = mean(var_wait),
            min_wait = mean(min_wait),
            max_wait = mean(max_wait),
            Qtile25th_wait = mean(Qtile25th_wait),
            Qtile75th_wait = mean(Qtile75th_wait),
            countunfinished = mean(countunfinished),
            countfinished = mean(countfinished)) %>%
  mutate(scenario = "baseline") # to identify it later

baseline_callwait_summary
```

## Scenario

If a neighbouring practice closed leading to an increase in demand of 45%. Whilst the practice were able to better advertise the ECR route to patients such that 30% of all the patients (old and new) were able to use this route. What  impact would this have on the call wait and reneging of patients?

### Trajectory for the scenario

Create a new distribution for the contact mode with 30% ECR and use this in a new version of the trajectory for this scenario.

```{r part 4: patient flow}
dist_contact_mode_S <- function() sample(1:2, 1, FALSE, c(0.3, 0.6))

patient_flow3 <- trajectory("patient flow3") %>%
  branch(dist_contact_mode_S, TRUE, # <- changed to the scenario distribution
         branch_ecr,
         branch_phone2) %>%
  timeout(dist_decision) %>%
  branch(dist_booking_type, TRUE,
         branch_booking_none,
         branch_booking_phone,
         branch_booking_f2f)
```

### Interarrivals for the scenario

Create scenario interarrival rates 1.45x higher than original by multiplying the number expected upward

```{r part 4: interarrival distributions}
dist_patient_interarrival1_S <- function() rexp(1, (120 * 1.45) / t_hour(2))
dist_patient_interarrival2_S <- function() rexp(1, (240 * 1.45) / t_hour(6))
dist_patient_interarrival3_S <- function() rexp(1,  (40 * 1.45) / t_hour(2))
```

###Scenario replications

Similar to the code used for the replications of the [baseline](#p3_baserep), run the new scenario trajectory 50 times. We
lapply as before but using the trajectory for the scenario (patient_flow3) and increasing frequency of arrivals using the scenarios interarrival distributions.

```{r part 4: replicate model runs, include=FALSE}
envs_scenario <- lapply(1:50, function(i) {
  set.seed(i)
  simmer("scenario") %>%
    add_resource("receptionist", capacity = sch_receptionists) %>%
    add_generator("patient[8am-10am]", patient_flow3,
                  from_to(t_hour(8), t_hour(10), dist_patient_interarrival1_S, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[10am-4pm]", patient_flow3,
                  from_to(t_hour(10), t_hour(16), dist_patient_interarrival2_S, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[4pm-6pm]", patient_flow3,
                  from_to(t_hour(16), t_hour(18), dist_patient_interarrival3_S, every = t_day(1)),
                  mon = 2) %>%
    run(t_day(5))
})
```

## Scenario results

Repurpose some of the code used to look at results in parts 1 and 2 of the workshop. Remembering to store the results with a different name to the baseline results.

### Count reneged:

```{r part 3: count reneged - scenario, warning=FALSE}
envs_scenario %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  group_by(replication) %>%
  summarise(countreneged = n()) %>%
  ungroup() %>%
  summarise(countreneged_mean = mean(countreneged))
```

n=752

### Count F2F bookings:

```{r part 3: count F2F - scenario, warning=FALSE}
envs_scenario %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  group_by(replication) %>%
  summarise(countF2F = n()) %>%
  ungroup() %>%
  summarise(countF2F_mean = mean(countF2F))
```

n=143

### Call waits:

```{r part 3: count F2F - scenario 2, warning=FALSE}
scenario_attributes <- envs_scenario %>%
  get_mon_attributes() %>%
  dplyr::select(-time) %>%
  pivot_wider(names_from = "key", values_from = "value", values_fill = 0)

scenario_callwait_results <- envs_scenario %>%
  get_mon_arrivals(ongoing = TRUE) %>%
  distinct() %>%
  full_join(scenario_attributes, by = c("name", "replication")) %>%
  filter(via_ecr == 0) %>%
  mutate(wait_time_call = case_when(
    # the caller reneged
    reneged == 1 ~ 5,
    # unfinished still in the system,
    !finished ~ t_day(5) - start_time,
    # everything else, (assume has been answered)
    TRUE      ~ pmax(end_time - start_time - activity_time, 0)
  ))

## calculate summary statistics
scenario_callwait_replication_summary <- scenario_callwait_results %>%
  group_by(replication) %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(!finished),
            countfinished = sum(finished)) %>%
  mutate(scenario = "scenario")

scenario_callwait_summary <- scenario_callwait_replication_summary %>%
  summarise(median_wait = mean(median_wait),
            mean_wait = mean(mean_wait),
            var_wait = mean(var_wait),
            min_wait = mean(min_wait),
            max_wait = mean(max_wait),
            Qtile25th_wait = mean(Qtile25th_wait),
            Qtile75th_wait = mean(Qtile75th_wait),
            countunfinished = mean(countunfinished),
            countfinished = mean(countfinished)) %>%
  mutate(scenario = "scenario")

# show top 10 results
head(scenario_callwait_summary, n = 10)
```

## Comparing results from the baseline and scenario

### Two sample T Test

Use `t.test()` function to compare waiting times between baseline and scenario and see if there is a significant difference in the results.

Version taught in slidepack:

```{r part 3: t-test}
t.test(scenario_callwait_results$wait_time_call, baseline_callwait_results$wait_time_call)
```

### Paired T-test

This could actually be a paired t-test because they use the same common random number set and have the same number of replications therefore replication 1 of baseline and scenario are correlated (unless the scenario itself changes the andom number sampling). 

We should check the variances of the differences is less than the individual variances before using paired t test. To do this, we need to:

- combine the baseline and scenario datasets, with a field for which result came from which.(We included a field for scenario in the earlier data manipulations, if not add this now using mutate)
- compute the difference between the scenario and baseline mean waits for each pair of replications
- conduct Shapiro-Wilk normality test for the differences and check p-value

```{r part 3: t-test version 2}
part3_summary_byreplication <- bind_rows(
  baseline_callwait_replication_summary,
  scenario_callwait_replication_summary
)

d <- with(
  part3_summary_byreplication,
  mean_wait[scenario == "baseline"] - mean_wait[scenario == "scenario"]
)

shapiro.test(d) # => p-value = 0.6375
```

The p-value (0.6375) is greater than the significance level 0.05  implying that the distribution of the differences (d) are not significantly different from normal distribution. therefore we do a paired T-Test.

```{r part 3 paired T}
res <- t.test(mean_wait ~ scenario, data = part3_summary_byreplication, paired = TRUE)

res
```

The p-value of the test is < 2.2e-16, which is less than the significance level, alpha = 0.05.
We can reject the null hypothesis and conclude that the average wait in the baseline is significantly different from the average wait in the scenario.

### Boxplot of the call waits in the baseline vs scenario

Using the ggplot2 package and geom_boxplot(), create boxplots of the means of the replications of the call waiting time in the baseline compared to the scenario. Set theme and title if you wish. To compare boxplots, you can either

a) create 2 different plots and put them on one chart using gridExtra package

```{r part 3: Boxplot part3a, warning=FALSE}
a <- ggplot(baseline_callwait_replication_summary) +
  geom_boxplot(aes(x = scenario, y = mean_wait),
               outlier.shape = 19,
               width = 0.3,
               fill = "white",
               colour = "orange") +
  labs(y = "mean call wait (mins)") +
  ylim(0, 4) +
  theme(axis.title.x = element_blank(),
        axis.text = element_text(size = 11))

b <- ggplot(scenario_callwait_replication_summary) +
  geom_boxplot(aes(x = scenario, y = mean_wait),
               outlier.shape = 19,
               width = 0.3,
               fill = "white",
               colour = "orange") +
  labs(y = "mean call wait (mins)") +
  ylim(0, 4) +
  theme(axis.title.x = element_blank(),
        axis.text = element_text(size = 11))

grid.arrange(a, b, ncol = 2, nrow = 1, top = "Call wait mean results of baseline(left) and scenario(right)")
```

b) Create one plot from combined dataset. Using bind_rows(), create one dataset with both scenarios and plot them together using ggplot2 already have the averages of by replications in part3_summary_byreplication

```{r part 3: Boxplot part3b, warning=FALSE}
part3_summary <- bind_rows(baseline_callwait_summary, scenario_callwait_summary)

# plot
g <- ggplot() +
  geom_boxplot(data = part3_summary_byreplication,
               aes(x = scenario, y = mean_wait),
               outlier.shape = 19,
               width = 0.3,
               fill = "white",
               colour = "orange") +
  geom_point(data = part3_summary,
             aes(x = scenario, y = mean_wait),
             shape = 19,
             size = 2,
             colour = "red") +
  labs(x = "scenario", y = "mean call wait (mins)", title = "Boxplot of mean call wait from 50 replications") +
  theme(axis.text = element_text(size = 11))

g
```

## Part 3 Questions

Q1. Looking at the results of baseline of 50 replications, what can you say about the results?

Q2. What do you interpret from the results of the scenario in comparison to the baseline?

### Q3. What other analysis might you want to do of the model results?

#### E.g. Compare ECR to Phones waits
Example if you want to compare ECR to Phones waits you might do it this way:

```{r part 3: additional analysis}
baseline_wait_results <- envs_baseline %>%
  get_mon_arrivals(ongoing = TRUE) %>%
  distinct() %>%
  full_join(baseline_attributes, by = c("name", "replication")) %>%
  filter(start_time >= 0) %>% # so use this to remove the not started e.g. start_time -1
  mutate(wait_time_call = case_when(
    reneged == 1 ~ 5,
    !finished ~ t_day(5) - start_time,
    TRUE      ~ pmax(end_time - start_time - activity_time, 0)
  ))

baseline_wait_replication_summary <- baseline_wait_results %>%
  group_by(replication, via_ecr) %>% #group by both of these to get results for phone and ECR
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(!finished),
            countfinished = sum(finished)) %>%
  mutate(scenario = "baseline")

# show top 10 results
head(baseline_wait_replication_summary, n = 10)

baseline_wait_summary <- baseline_wait_replication_summary %>%
  group_by(via_ecr) %>%
  summarise(median_wait = mean(median_wait),
            mean_wait = mean(mean_wait),
            var_wait = mean(var_wait),
            min_wait = mean(min_wait),
            max_wait = mean(max_wait),
            Qtile25th_wait = mean(Qtile25th_wait),
            Qtile75th_wait = mean(Qtile75th_wait),
            countunfinished = mean(countunfinished),
            countfinished = mean(countfinished))

baseline_wait_summary
```

### Q4. What other ways might you want to present data?

#### E.g. Waiting times for the replications

For example, plot results from all replications

```{r part 3: additional charts 1}
plot(get_mon_arrivals(envs_baseline), metric = "waiting_time")
plot(get_mon_arrivals(envs_scenario), metric = "waiting_time")
```

#### E.g. Histogram of average waits

We could produce a chart showing the mean call wait from each of the 50 replications.

```{r part 3: additional charts 2}
ggplot(part3_summary_byreplication, aes(mean_wait)) +
  geom_histogram(fill = "orange") +
  labs(title = "Distribution of average call wait in 50 replications") +
  facet_wrap(vars(scenario), ncol = 2)
```

## Option B: Part 3 using the now() function

### Baseline trajectory and replications

To include the set_attribute using now() we reference the correct environment for each replication

```{r part 3: option B set up, include=FALSE}
envs_baselineB <- lapply(1:50, function(i) {
  assign(paste("env", i[1], sep = "_"), simmer("baselineB"))
  get(paste0("env_", i))

  # change references to env
  renege_hungup3B <- trajectory("hung up") %>%
    set_attribute("reneged", 1) %>%
    set_attribute("reneged_at", function() now(get(paste0("env_", i)))) %>% # changed to env_part2B
    log_("lost my patience. Hanging up...")

  branch_phone3B <- trajectory("branch phone") %>%
    set_prioritization(c(1, 1, FALSE)) %>% # set to increase priority from default of 0 to 1, no preempt and no restart
    set_attribute("via_ecr", 0) %>%
    set_attribute("arrival", function() now(get(paste0("env_", i)))) %>% # changed to env_part2B
    renege_in(t = 5, out = renege_hungup) %>%
    seize("receptionist") %>%
    set_attribute("call_taken", function() now(get(paste0("env_", i)))) %>% # changed to env_part2B
    renege_abort() %>%
    timeout(dist_screening)

  branch_booking_none3B <- trajectory("no appointment needed") %>%
    release("receptionist") %>%
    set_attribute("booked_appt", 0) %>%
    set_attribute("call_end", function() now(get(paste0("env_", i)))) # changed to env_part2B

  branch_booking_phone3B <- trajectory("booking a f2f") %>%
    timeout(dist_booking) %>%
    release("receptionist") %>%
    set_attribute("booked_appt", 1) %>%
    set_attribute("call_end", function() now(get(paste0("env_", i)))) # changed to env_part2B

  branch_booking_f2f3B <- trajectory("booking a f2f") %>%
    timeout(dist_booking) %>%
    release("receptionist") %>%
    set_attribute("booked_appt", 2) %>%
    set_attribute("call_end", function() now(get(paste0("env_", i)))) # changed to env_part2B

  # Overall trajectory:

  rm(patient_flow3B)
  patient_flow3B <- trajectory("patient flow3B") %>%
    branch(dist_contact_mode, TRUE,
           branch_ecr,
           branch_phone3B) %>%
    timeout(dist_decision) %>%
    branch(dist_booking_type, TRUE,
           branch_booking_none3B,
           branch_booking_phone3B,
           branch_booking_f2f3B)

  set.seed(i)
  get(paste0("env_", i)) %>%
    add_resource("receptionist", capacity = sch_receptionists) %>%
    add_generator("patient[8am-10am]", patient_flow3B,
                  from_to(t_hour(8), t_hour(10), dist_patient_interarrival1, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[10am-4pm]", patient_flow3B,
                  from_to(t_hour(10), t_hour(16), dist_patient_interarrival2, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[4pm-6pm]", patient_flow3B,
                  from_to(t_hour(16), t_hour(18), dist_patient_interarrival3, every = t_day(1)),
                  mon = 2) %>%
    run(t_day(5))
})
```

We can now analyse results

### Baseline results part 3B

#### Count reneged:

```{r part 3: option B Q1}
envs_baselineB %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  group_by(replication) %>%
  summarise(countreneged = n()) %>%
  ungroup() %>%
  summarise(countreneged_mean = mean(countreneged))
```

n=580

#### Count F2F bookings:

```{r part 3: option B Q2}
envs_baselineB %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  group_by(replication) %>%
  summarise(countF2F = n()) %>%
  ungroup() %>%
  summarise(countF2F_mean = mean(countF2F))
```

n=143

#### Call waits:

```{r part 3: option B Q3}
baselineB_callwait_results <- envs_baselineB %>%
  get_mon_attributes() %>%
  pivot_wider(-c(time), names_from = key, values_from = value) %>%
  filter(via_ecr == 0, arrival >= 0) %>%
  mutate(wait_time_call = case_when(
    !is.na(reneged) ~ 5,
    is.na(call_taken) ~ t_day(5) - arrival,
    TRUE ~ call_taken - arrival 
  ))

baselineB_callwait_replication_summary <- baselineB_callwait_results %>%
  group_by(replication) %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(is.na(call_end) & is.na(reneged)),
            countfinished = sum(!is.na(call_end) | !is.na(reneged)))

# show top 10 results
head(baselineB_callwait_replication_summary, n = 10)

baselineB_callwait_summary <- baselineB_callwait_replication_summary %>%
  summarise(median_wait = mean(median_wait),
            mean_wait = mean(mean_wait),
            var_wait = mean(var_wait),
            min_wait = mean(min_wait),
            max_wait = mean(max_wait),
            Qtile25th_wait = mean(Qtile25th_wait),
            Qtile75th_wait = mean(Qtile75th_wait),
            countunfinished = mean(countunfinished),
            countfinished = mean(countfinished)) %>%
  mutate(scenario = "baseline") # to identify it later

baselineB_callwait_summary

baselineB_callwait_summary$mean_wait
baseline_callwait_summary$mean_wait
```

### Scenario with option B

Trajectory must be included inside the lapply for replication

```{r part 3: option B set up scenario, include=FALSE}
envs_scenarioB <- lapply(1:50, function(i) {
  assign(paste("env", i[1], sep = "_"), simmer("scenarioB"))
  get(paste0("env_", i))

  # change references to env
  renege_hungup3B <- trajectory("hung up") %>%
    set_attribute("reneged", 1) %>%
    set_attribute("reneged_at", function() now(get(paste0("env_", i)))) %>% # changed to env_part2B
    log_("lost my patience. Hanging up...")

  branch_phone3B <- trajectory("branch phone") %>%
    set_prioritization(c(1, 1, FALSE)) %>% # set to increase priority from default of 0 to 1, no preempt and no restart
    set_attribute("via_ecr", 0) %>%
    set_attribute("arrival", function() now(get(paste0("env_", i)))) %>% # changed to env_part2B
    renege_in(t = 5, out = renege_hungup) %>%
    seize("receptionist") %>%
    set_attribute("call_taken", function() now(get(paste0("env_", i)))) %>% # changed to env_part2B
    renege_abort() %>%
    timeout(dist_screening)

  branch_booking_none3B <- trajectory("no appointment needed") %>%
    release("receptionist") %>%
    set_attribute("booked_appt", 0) %>%
    set_attribute("call_end", function() now(get(paste0("env_", i)))) # changed to env_part2B

  branch_booking_phone3B <- trajectory("booking a f2f") %>%
    timeout(dist_booking) %>%
    release("receptionist") %>%
    set_attribute("booked_appt", 1) %>%
    set_attribute("call_end", function() now(get(paste0("env_", i)))) # changed to env_part2B

  branch_booking_f2f3B <- trajectory("booking a f2f") %>%
    timeout(dist_booking) %>%
    release("receptionist") %>%
    set_attribute("booked_appt", 2) %>%
    set_attribute("call_end", function() now(get(paste0("env_", i)))) # changed to env_part2B

  # Overall trajectory:
  rm(patient_flow3BS)

  # Create a new patient flow trajectory using the new contact mode distribution
  patient_flow3BS <- trajectory("patient flow3BS") %>%
    branch(dist_contact_mode_S, TRUE, # <-changed to the scenario distribution
           branch_ecr,
           branch_phone3B) %>%
    timeout(dist_decision) %>%
    branch(dist_booking_type, TRUE,
           branch_booking_none3B,
           branch_booking_phone3B,
           branch_booking_f2f3B)

  set.seed(i)
  get(paste0("env_", i)) %>%
    add_resource("receptionist", capacity = sch_receptionists) %>%
    add_generator("patient[8am-10am]", patient_flow3BS,
                  from_to(t_hour(8), t_hour(10), dist_patient_interarrival1_S, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[10am-4pm]", patient_flow3BS,
                  from_to(t_hour(10), t_hour(16), dist_patient_interarrival2_S, every = t_day(1)),
                  mon = 2) %>%
    add_generator("patient[4pm-6pm]", patient_flow3BS,
                  from_to(t_hour(16), t_hour(18), dist_patient_interarrival3_S, every = t_day(1)),
                  mon = 2) %>%
    run(t_day(5))
})
```

We can now analyse results

#### Count reneged:

```{r part 3: option B Q1 scenario}
envs_scenarioB %>%
  get_mon_attributes() %>%
  filter(key == "reneged") %>%
  group_by(replication) %>%
  summarise(countreneged = n()) %>%
  ungroup() %>%
  summarise(countreneged_mean = mean(countreneged))
```

n=752

#### Count F2F bookings:

```{r part 3: option B Q2 scenario}
envs_scenarioB %>%
  get_mon_attributes() %>%
  filter(key == "booked_appt", value == 2) %>%
  group_by(replication) %>%
  summarise(countF2F = n()) %>%
  ungroup() %>%
  summarise(countF2F_mean = mean(countF2F))
```

n=165

#### Call waits:

```{r part 3: option B Q3 scenario}
scenarioB_callwait_results <- envs_scenarioB %>%
  get_mon_attributes() %>%
  pivot_wider(-c(time), names_from = key, values_from = value) %>%
  filter(via_ecr == 0, arrival >= 0) %>%
  mutate(wait_time_call = case_when(
    !is.na(reneged) ~ 5,
    is.na(call_taken) ~ t_day(5) - arrival,
    TRUE ~ call_taken - arrival 
  ))

scenarioB_callwait_replication_summary <- scenarioB_callwait_results %>%
  group_by(replication) %>%
  summarise(median_wait = median(wait_time_call),
            mean_wait = mean(wait_time_call),
            var_wait = var(wait_time_call),
            min_wait = min(wait_time_call),
            max_wait = max(wait_time_call),
            Qtile25th_wait = quantile(wait_time_call, probs = 0.25),
            Qtile75th_wait = quantile(wait_time_call, probs = 0.75),
            countunfinished = sum(is.na(call_end) & is.na(reneged)),
            countfinished = sum(!is.na(call_end) | !is.na(reneged)))

# show top 10 results
head(scenarioB_callwait_replication_summary, n = 10)

scenarioB_callwait_summary <- scenarioB_callwait_replication_summary %>%
  summarise(median_wait = mean(median_wait),
            mean_wait = mean(mean_wait),
            var_wait = mean(var_wait),
            min_wait = mean(min_wait),
            max_wait = mean(max_wait),
            Qtile25th_wait = mean(Qtile25th_wait),
            Qtile75th_wait = mean(Qtile75th_wait),
            countunfinished = mean(countunfinished),
            countfinished = mean(countfinished)) %>%
  mutate(scenario = "scenario") # to identify it later

scenarioB_callwait_summary

scenarioB_callwait_summary$mean_wait
scenario_callwait_summary$mean_wait
```


## Additional questions if you want to explore model further

Q1. What other opportunities are there for improvement of the process?

Q2. What other scenarios might you want to consider with the practice? What would your performance indicators be? How would you incorporate them in the model? Have a go if you have time.

Examples might include staff rota, opening hours, percentage coming via ecr, include preemption and restart as a way of working

Q3. What else would need to be considered before they could implement changes suggested by the model? 

E.g. costs, other tasks the staff do, feasibility of suggested rota in real life.

### Q4. Are we running the model for a sufficient number of runs?

This process has been converted to R from: Simulations: The Practice of Model Development and Use, Robinson, S., 2nd Ed. 2014, Palgrave Macmillan

Remember back to our T test results we saved in res, these gave a confidence interval based on the student's t distribution

```{r part 3: confidence intervals for t-test 1}
res$conf.int[1]
res$conf.int[2]
```

We can use this to look the percent deviation of the confidence limits from the mean as the number of replications increases to help us determine accuracy of our mean from these.

Create a blank data frame to hold the cumulative results and then loop through: 

```{r part 3: sufficient replications 1}
check_baseline_replications <- data.frame(matrix(ncol = 5, nrow = 0))
x <- c("replication", "cmean", "tL", "tU", "percentdeviation")
colnames(check_baseline_replications) <- x

#loop through increasing the number of replications
for (i in 2:50) {
  df <- baseline_callwait_replication_summary %>%
    dplyr::select(replication, mean_wait) %>%
    filter(replication <= i) %>%
    summarise(replication = i,
              cmean = mean(mean_wait),
              tL = t.test(mean_wait)$conf.int[1],
              tU = t.test(mean_wait)$conf.int[2],
              percentdeviation = (cmean - tL) / cmean * 100) %>%
    data.frame()
  check_baseline_replications <- bind_rows(check_baseline_replications, df)
}

# show top 10 results
head(check_baseline_replications, n = 10)
```

